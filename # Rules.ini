# Rules

## Table of Contents
1. [Architecture Overview](#architecture-overview)
2. [Project Structure](#project-structure)
3. [Layer Guidelines](#layer-guidelines)
4. [Naming Conventions](#naming-conventions)
5. [State Management Rules](#state-management-rules)
6. [Navigation Rules](#navigation-rules)
7. [Code Organization Rules](#code-organization-rules)
8. [Dependencies Rules](#dependencies-rules)
9. [Testing Rules](#testing-rules)
10. [Best Practices](#best-practices)

---

## Architecture Overview

This project follows **Clean Architecture** principles combined with the **BLoC (Business Logic Component)** pattern for state management.

### Architecture Layers

```
┌─────────────────────────────────────┐
│     Presentation Layer              │
│  (Screens, Widgets, Router)        │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     Business Logic Layer            │
│  (BLoC, Cubit, Events, States)      │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     Repository Layer                │
│  (DataManager, Data Abstraction)    │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     Data Provider Layer             │
│  (Network, Models, API Client)      │
└─────────────────────────────────────┘
```

---

## Project Structure

### Directory Organization

```
lib/
├── businessLogic/          # Business logic layer
│   ├── bloc/               # BLoC implementations
│   │   └── [feature]Bloc/  # Feature-specific BLoC
│   │       ├── [feature]_bloc.dart
│   │       ├── [feature]_event.dart
│   │       ├── [feature]_state.dart
│   │       └── [feature]_bloc.freezed.dart
│   └── cubit/              # Cubit implementations (simple state)
│
├── presentation/           # UI layer
│   ├── screens/            # Screen widgets
│   │   └── [feature]/      # Feature-specific screens
│   ├── widgets/            # Reusable widgets
│   │   └── [feature]/      # Feature-specific widgets
│   ├── router/             # Navigation configuration
│   │   ├── app_router.dart
│   │   └── routes.dart
│   └── arguments/          # Screen arguments/models
│
├── repository/             # Data abstraction layer
│   ├── data_manager.dart
│   └── data_manager_imp.dart
│
├── dataProvider/           # Data source layer
│   ├── network/            # API client and interceptors
│   └── model/              # Data models
│       └── response/       # API response models
│
├── helper/                 # Utilities and helpers
│   ├── constant/           # Constants, resources
│   ├── theme/              # App themes
│   ├── service/            # Services (network status, etc.)
│   ├── util/               # Utility functions
│   └── enum/               # Enumerations
│
└── main.dart               # Application entry point
```

---

## Layer Guidelines

### 1. Presentation Layer (`lib/presentation/`)

#### Rules:
- ✅ **DO**: Keep screens focused on UI rendering only
- ✅ **DO**: Use `BlocBuilder` or `BlocConsumer` to listen to state changes
- ✅ **DO**: Extract reusable UI components to `widgets/` directory
- ✅ **DO**: Group widgets by feature in subdirectories
- ✅ **DO**: Use `flutter_screenutil` for responsive design
- ❌ **DON'T**: Put business logic in screens
- ❌ **DON'T**: Make direct API calls from screens
- ❌ **DON'T**: Access data layer directly from presentation layer

#### Screen Structure:
```dart
class FeatureScreen extends StatelessWidget {
  const FeatureScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<FeatureBloc, FeatureState>(
      builder: (context, state) {
        // UI implementation
      },
    );
  }
}
```

#### Widget Structure:
```dart
class FeatureWidget extends StatelessWidget {
  const FeatureWidget({super.key, required this.param});

  final String param;

  @override
  Widget build(BuildContext context) {
    // Widget implementation
  }
}
```

### 2. Business Logic Layer (`lib/businessLogic/`)

#### Rules:
- ✅ **DO**: Use BLoC for complex state management
- ✅ **DO**: Use Cubit for simple state management
- ✅ **DO**: Use Freezed for immutable state and events
- ✅ **DO**: Keep business logic pure (no UI dependencies)
- ✅ **DO**: Handle all side effects (API calls, navigation) in BLoC
- ❌ **DON'T**: Import Flutter UI packages in BLoC
- ❌ **DON'T**: Put UI logic in BLoC
- ❌ **DON'T**: Create BLoC instances in screens (use router/provider)

#### BLoC Structure:
```dart
// Event (using Freezed)
part 'feature_event.dart';

@freezed
class FeatureEvent with _$FeatureEvent {
  const factory FeatureEvent.onLoadData() = _OnLoadData;
  const factory FeatureEvent.onUpdateData(String data) = _OnUpdateData;
}

// State (using Freezed)
part 'feature_state.dart';

@freezed
class FeatureState with _$FeatureState {
  const factory FeatureState({
    @Default(false) bool isLoading,
    @Default('') String data,
    String? error,
  }) = _FeatureState;
}

// BLoC Implementation
class FeatureBloc extends Bloc<FeatureEvent, FeatureState> {
  final DataManager dataManager;
  
  FeatureBloc({required this.dataManager}) : super(const FeatureState()) {
    on<_OnLoadData>(_onLoadData);
  }
  
  Future<void> _onLoadData(
    _OnLoadData event,
    Emitter<FeatureState> emit,
  ) async {
    emit(state.copyWith(isLoading: true));
    // Business logic here
  }
}
```

### 3. Repository Layer (`lib/repository/`)

#### Rules:
- ✅ **DO**: Implement `DataManagerImp` interface
- ✅ **DO**: Abstract data sources (network, local storage)
- ✅ **DO**: Handle error transformation
- ✅ **DO**: Return consistent response models
- ❌ **DON'T**: Expose data provider implementation details
- ❌ **DON'T**: Put business logic in repository

#### Repository Structure:
```dart
abstract class DataManagerImp {
  Future<dynamic> getData();
}

class DataManager implements DataManagerImp {
  final NetworkApiClient _networkApiClient;
  
  DataManager({required NetworkApiClient networkApiClient})
      : _networkApiClient = networkApiClient;
  
  @override
  Future<dynamic> getData() {
    return _networkApiClient
        .getData()
        .then((response) => response)
        .catchError((e) => _handleError(e));
  }
  
  MainResponseModel _handleError(DioError e) {
    // Error handling logic
  }
}
```

### 4. Data Provider Layer (`lib/dataProvider/`)

#### Rules:
- ✅ **DO**: Use Retrofit for API client generation
- ✅ **DO**: Use Dio for HTTP requests
- ✅ **DO**: Implement interceptors for common concerns (auth, logging)
- ✅ **DO**: Use Freezed for response models
- ✅ **DO**: Keep models immutable
- ❌ **DON'T**: Put business logic in data provider
- ❌ **DON'T**: Expose raw network errors to upper layers

#### Model Structure:
```dart
@freezed
class ResponseModel with _$ResponseModel {
  const factory ResponseModel({
    required bool status,
    required String message,
    String? errorCode,
    dynamic data,
  }) = _ResponseModel;
  
  factory ResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ResponseModelFromJson(json);
}
```

---

## Naming Conventions

### Files and Directories

#### Screens:
- File: `[feature]_screen.dart`
- Class: `[Feature]Screen`
- Example: `home_screen.dart` → `HomeScreen`

#### Widgets:
- File: `[feature]_widget.dart` or `[feature]_[type].dart`
- Class: `[Feature]Widget` or `[Feature][Type]`
- Example: `custom_button.dart` → `CustomButton`

#### BLoC:
- File: `[feature]_bloc.dart`, `[feature]_event.dart`, `[feature]_state.dart`
- Class: `[Feature]Bloc`, `[Feature]Event`, `[Feature]State`
- Example: `auth_bloc.dart` → `AuthBloc`

#### Models:
- File: `[feature]_model.dart`
- Class: `[Feature]Model`
- Example: `profile_model.dart` → `ProfileModel`

#### Routes:
- Constant: `[FEATURE]_SCREEN_ROUTE`
- Value: `"/[feature]ScreenRoute"`
- Example: `HOME_SCREEN_ROUTE = "/homeScreenRoute"`

### Variables and Functions

- **Variables**: `camelCase`
- **Constants**: `UPPER_SNAKE_CASE`
- **Private variables**: `_camelCase` (leading underscore)
- **Functions**: `camelCase`
- **Private functions**: `_camelCase` (leading underscore)
- **Classes**: `PascalCase`
- **Enums**: `PascalCase` with values in `camelCase`

---

## State Management Rules

### BLoC Usage

1. **When to use BLoC**:
   - Complex state with multiple events
   - Need for event history/logging
   - Multiple screens sharing state

2. **When to use Cubit**:
   - Simple state management
   - Single screen state
   - No need for event tracking

### State Management Best Practices

- ✅ **DO**: Emit new state objects (immutable)
- ✅ **DO**: Use `copyWith` for state updates
- ✅ **DO**: Handle loading, success, and error states
- ✅ **DO**: Dispose BLoC properly
- ❌ **DON'T**: Mutate state directly
- ❌ **DON'T**: Emit states synchronously after async operations without checking if BLoC is closed
- ❌ **DON'T**: Create BLoC instances in `build` method

### BLoC Provider Pattern

```dart
// In Router
BlocProvider(
  create: (context) => FeatureBloc()..add(const FeatureEvent.onLoad()),
  child: const FeatureScreen(),
)

// In Screen
BlocBuilder<FeatureBloc, FeatureState>(
  builder: (context, state) {
    if (state.isLoading) return LoadingWidget();
    if (state.error != null) return ErrorWidget(state.error!);
    return ContentWidget(state.data);
  },
)
```

---

## Navigation Rules

### Router Configuration

1. **Route Definition**:
   - Define all routes in `lib/presentation/router/routes.dart`
   - Use constants for route names
   - Follow naming: `[FEATURE]_SCREEN_ROUTE`

2. **Route Generation**:
   - Implement route generation in `app_router.dart`
   - Provide BLoC instances in router
   - Handle route arguments properly

3. **Navigation**:
   - Use `Navigator.pushNamed()` for navigation
   - Pass arguments via `arguments` parameter
   - Use typed argument classes when possible

### Navigation Example

```dart
// Define route
const PROFILE_DETAIL_SCREEN_ROUTE = "/profileDetailScreenRoute";

// Navigate
Navigator.pushNamed(
  context,
  PROFILE_DETAIL_SCREEN_ROUTE,
  arguments: {'profileId': '123', 'isEditMode': true},
);

// Handle in router
case PROFILE_DETAIL_SCREEN_ROUTE:
  final args = routeSettings.arguments as Map<String, dynamic>?;
  return MaterialPageRoute(
    builder: (_) => BlocProvider(
      create: (context) => ProfileDetailBloc(),
      child: ProfileDetailScreen(
        profileId: args?['profileId'] ?? '',
        isEditMode: args?['isEditMode'] ?? false,
      ),
    ),
  );
```

---

## Code Organization Rules

### Import Organization

1. **Import Order**:
   ```dart
   // 1. Dart SDK imports
   import 'dart:async';
   
   // 2. Flutter imports
   import 'package:flutter/material.dart';
   
   // 3. Package imports (alphabetical)
   import 'package:bloc/bloc.dart';
   import 'package:flutter_bloc/flutter_bloc.dart';
   
   // 4. Project imports (grouped by layer)
   import 'package:vouch_app/businessLogic/bloc/featureBloc/feature_bloc.dart';
   import 'package:vouch_app/presentation/widgets/feature_widget.dart';
   import 'package:vouch_app/helper/constant/colors_resource.dart';
   ```

2. **Import Rules**:
   - Use relative imports only within the same package
   - Use absolute imports for cross-layer imports
   - Group imports with blank lines

### File Organization

1. **Class Structure**:
   ```dart
   // 1. Imports
   
   // 2. Class declaration
   class FeatureScreen extends StatelessWidget {
     // 3. Constructor
     const FeatureScreen({super.key});
     
     // 4. Public methods
     @override
     Widget build(BuildContext context) {
       // Implementation
     }
     
     // 5. Private methods
     void _privateMethod() {}
   }
   ```

2. **Widget Structure**:
   - Keep widgets small and focused
   - Extract complex widgets into separate files
   - Use `const` constructors when possible

---

## Dependencies Rules

### Dependency Flow

```
Presentation → Business Logic → Repository → Data Provider
     ↓              ↓              ↓
   Helper ←────── Helper ←────── Helper
```

### Rules:
- ✅ **DO**: Dependencies flow inward (presentation depends on business logic, not vice versa)
- ✅ **DO**: Use dependency injection (constructor injection)
- ✅ **DO**: Abstract dependencies with interfaces
- ❌ **DON'T**: Create circular dependencies
- ❌ **DON'T**: Import outer layers from inner layers

### Dependency Injection

```dart
// In Router
class AppRouter {
  late final DataManager dataManager;
  
  AppRouter() {
    dataManager = DataManager(
      networkApiClient: NetworkApiClient(
        Dio()..interceptors.add(NetworkInterceptor()),
      ),
    );
  }
}

// In BLoC
class FeatureBloc extends Bloc<FeatureEvent, FeatureState> {
  final DataManager dataManager;
  
  FeatureBloc({required this.dataManager}) : super(const FeatureState());
}
```

---

## Testing Rules

### Test Structure

```
test/
├── unit/                    # Unit tests
│   ├── businessLogic/       # BLoC tests
│   └── repository/          # Repository tests
├── widget/                  # Widget tests
└── integration/             # Integration tests
```

### Testing Guidelines

- ✅ **DO**: Write unit tests for BLoC
- ✅ **DO**: Write widget tests for complex widgets
- ✅ **DO**: Mock dependencies in tests
- ✅ **DO**: Test error scenarios
- ❌ **DON'T**: Test implementation details
- ❌ **DON'T**: Skip testing edge cases

---

## Best Practices

### General

1. **Code Quality**:
   - Follow Dart style guide
   - Use `flutter analyze` before committing
   - Keep functions small and focused
   - Write self-documenting code

2. **Performance**:
   - Use `const` constructors when possible
   - Avoid unnecessary rebuilds
   - Use `ListView.builder` for long lists
   - Cache network images

3. **Error Handling**:
   - Handle all error cases
   - Show user-friendly error messages
   - Log errors for debugging
   - Use try-catch for async operations

4. **Localization**:
   - Use `easy_localization` for all user-facing strings
   - Never hardcode strings
   - Store translations in `assets/translations/`

5. **Theming**:
   - Use theme colors from `AppTheme`
   - Support dark mode
   - Use responsive dimensions from `DimensionsResource`

### Screen-Specific

1. **Responsive Design**:
   - Use `flutter_screenutil` for sizing
   - Use `.h` for height, `.w` for width
   - Test on multiple screen sizes

2. **State Management**:
   - Use `BlocBuilder` for UI updates
   - Use `BlocListener` for side effects (navigation, snackbars)
   - Use `BlocConsumer` when you need both

3. **Widget Reusability**:
   - Extract reusable widgets
   - Create feature-specific widget directories
   - Use composition over inheritance

### BLoC-Specific

1. **Event Naming**:
   - Use descriptive names: `onLoadData`, `onUpdateProfile`
   - Prefix with `on` for user actions
   - Use past tense for completed actions: `onDataLoaded`

2. **State Management**:
   - Keep state immutable
   - Use Freezed for state classes
   - Handle loading, success, and error states

3. **Side Effects**:
   - Handle navigation in BLoC (via callbacks or router)
   - Show toasts/snackbars via state changes
   - Don't perform side effects in event handlers directly

---

## Code Review Checklist

Before submitting code for review, ensure:

- [ ] Follows naming conventions
- [ ] No business logic in presentation layer
- [ ] BLoC handles all state changes
- [ ] Error handling implemented
- [ ] Localization strings used (no hardcoded text)
- [ ] Responsive design implemented
- [ ] Dark mode supported
- [ ] No circular dependencies
- [ ] Imports organized correctly
- [ ] Code formatted (`dart format`)
- [ ] No linter errors (`flutter analyze`)
- [ ] Tests written (if applicable)

---

## Common Patterns

### Loading State Pattern

```dart
@freezed
class FeatureState with _$FeatureState {
  const factory FeatureState({
    @Default(false) bool isLoading,
    String? data,
    String? error,
  }) = _FeatureState;
}

// In BLoC
Future<void> _onLoadData(
  _OnLoadData event,
  Emitter<FeatureState> emit,
) async {
  emit(state.copyWith(isLoading: true, error: null));
  try {
    final result = await dataManager.getData();
    emit(state.copyWith(isLoading: false, data: result));
  } catch (e) {
    emit(state.copyWith(isLoading: false, error: e.toString()));
  }
}
```

### Error Handling Pattern

```dart
// In Repository
MainResponseModel errorHandling(DioError e) {
  final errorResponse = e.response;
  if (errorResponse?.data['response'] != null) {
    var jsonResponse = MainResponseModel.fromJson(errorResponse?.data);
    return MainResponseModel(
      response: ResponseModel(
        message: jsonResponse.response.message,
        status: jsonResponse.response.status,
        errorCode: errorResponse?.statusCode,
      ),
    );
  } else {
    return MainResponseModel(
      response: ResponseModel(
        message: StringsResource.STH_WENT_WRONG,
        status: false,
        errorCode: errorResponse?.statusCode,
      ),
    );
  }
}
```

---

## Version Control

### Branch Naming
- `feature/[feature-name]` - New features
- `bugfix/[bug-name]` - Bug fixes
- `refactor/[refactor-name]` - Code refactoring
- `hotfix/[hotfix-name]` - Critical fixes

### Commit Messages
- Use descriptive commit messages
- Reference issue numbers if applicable
- Follow conventional commits format

---

## Resources

- [Flutter Style Guide](https://flutter.dev/docs/development/ui/widgets-intro)
- [BLoC Documentation](https://bloclibrary.dev/)
- [Freezed Documentation](https://pub.dev/packages/freezed)
- [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

---

**Last Updated**: 2024
**Maintained By**: Development Team
